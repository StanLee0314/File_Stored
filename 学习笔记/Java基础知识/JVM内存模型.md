# JVM第二天

## JVM内存模型（JMM)

>  根据java虚拟机规范，java虚拟机管理的内存将分为下面五大区域。
>
>
> ![img](https://upload-images.jianshu.io/upload_images/10006199-a4108d8fb7810a71.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp) 

#### 1. 程序计数器

> ```undefined
> 程序计数器是一块很小的内存空间，它是线程私有的，可以认作为当前线程的行号指示器。
> ```

 **为什么需要程序计数器** 

> 我们知道对于一个处理器在一个确定的时刻都只会执行一条线程中的指令，一条线程中有多个指令，为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计数器，不同线程之间的程序计数器互不影响，独立存储。
>
> 注意：如果线程执行的是个java方法，那么计数器记录虚拟机字节码指令的地址。如果为native【底层方法】，那么计数器为空。**这块内存区域是虚拟机规范中唯一没有OutOfMemoryError的区域**。

#### 2. Java栈（虚拟机栈）

>  同计数器也为线程私有，生命周期与相同，就是我们平时说的栈，**栈描述的是Java方法执行的内存模型**。 
>
>  **每个方法被执行的时候都会创建一个栈帧用于存储局部变量表，操作栈，动态链接，方法出口等信息。每一个方法被调用的过程就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。** 

```
栈帧: 是用来存储数据和部分过程结果的数据结构。
栈帧的位置:  内存 -> 运行时数据区 -> 某个线程对应的虚拟机栈 -> here[在这里]
栈帧大小确定时间: 编译期确定，不受运行期数据影响。
```

> Java虚拟机栈可能出现两种类型的异常：
>
> 1. 线程请求的栈深度大于虚拟机允许的栈深度，将抛出StackOverflowError。
> 2. 虚拟机栈空间可以动态扩展，当动态扩展是无法申请到足够的空间时，抛出OutOfMemory异常。

#### 3. 本地方法栈

> 本地方法栈是与虚拟机栈发挥的作用十分相似,区别是虚拟机栈执行的是Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的native方法服务，可能底层调用的c或者c++,我们打开jdk安装目录可以看到也有很多用c编写的文件，可能就是native方法所调用的c代码。

#### 4. 方法区

> 方法区同堆一样，是所有线程共享的内存区域，为了区分堆，又被称为非堆。
>
> 用于存储已被虚拟机加载的类信息、常量、静态变量，如static修饰的变量加载类的时候就被加载到方法区中。
>
> 
>
> 运行时常量池
>
> 是方法区的一部分，class文件除了有类的字段、接口、方法等描述信息之外，还有常量池用于存放编译期间生成的各种字面量和符号引用。
>
> 
>
>  自从JDK7之后，Hotspot虚拟机将运行时常量池从永久代移除了。 

#### 5. 堆

> 对于大多数应用来说，**堆是java虚拟机管理内存最大的一块内存区域，因为堆存放的对象是线程共享的，所以多线程的时候也需要同步机制**。
>
> 大多数情况下所有对象实例及数组都要在堆上分配内存
>
> JVM 根据对象的存活周期不同，把堆内存划分为两块，一般为新生代、老年代。在绝大多数情况下，新创建的对象首先分配在eden区，在一次新生代回收之后，如果对象还存活，则进入s0或者s1，每经过一次新生代回收，对象如果存活，它的年龄就会加1。当对象的年龄达到一定条件后，就会被认为是老年对象，从而进入老年代。

#### 对象的内存布局

>  在HotSpot虚拟机中。对象在内存中存储的布局分为 
>
> ```undefined
> 1.对象头
> 2.实例数据
> 3.对齐填充
> ```

##### 对象头【markword】

 在32位系统下，对象头8字节，64位则是16个字节【未开启压缩指针，开启后12字节】。 

##### 实例数据

> ```cpp
> 存放对象程序中各种类型的字段类型，不管是从父类中继承下来的还是在子类中定义的。
> 分配策略:相同宽度的字段总是放在一起，比如double和long
> ```

##### 对齐填充

>  这部分没有特殊的含义，仅仅起到占位符的作用满足JVM要求。 
>
> ```undefined
> 由于HotSpot规定对象的大小必须是8的整数倍，对象头刚好是整数倍，如果实例数据不是的话，就需要占位符对齐填充。
> ```
