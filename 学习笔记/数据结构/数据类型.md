# ArrayList,List和数组的区别

### 数组(先有数组,后面才有ArrayList等等一系列的优化)

- 数组在内存中是连续存储的，所以它的索引速度是非常的快，而且赋值与修改元素也很简单
- 但同时,数组也存在一些不足,比如在数组的两个数据间插入数据是非常麻烦的，还有在声明数组的时候，必须同时指明数组的长度，数组的长度过长，会造成内存浪费，数组长度过短，会造成数据溢出的错误。所以C#语言提供了ArrayList对象来克服这些缺点。

### ArrayList

ArrayList是.Net Framework提供的用于数据存储和检索的专用类，它是命名空间System.Collections下的一部分。它的大小是按照其中存储的数据来动态扩充与收缩的。所以，我们在声明ArrayList对象时并不需要指定它的长度。ArrayList继承了IList接口，所以它可以很方便的进行数据的添加，插入和移除.比如：

```cpp
ArrayList list = new ArrayList();
//新增数据
 list.Add("acrs");
 list.Add(123);
//修改数据
 list[2] = 345;  //修改索引位置为2的值,将值修改为345;
//移除数据
 list.RemoveAt(2);  //移除索引为2的数据
//插入数据 
list.Insert(0, "hello world");  //插入索引位置为0,数值为"hello world"
```

从上面示例看，ArrayList好像是解决了数组中所有的缺点，但它同样存在缺点,那就是类型不安全和性能损耗大(由于存在装箱,拆箱)，所以在C#2.0后又会出现List对象来补充它.
 　在上面的代码中,我们不仅插入了字符串"acrs"，而且又插入了数字123。这样在ArrayList中插入不同类型的数据是允许的。因为ArrayList会把所有插入其中的数据都当作为object类型来处理。这样，在我们使用ArrayList中的数据来处理问题的时候，很可能会报类型不匹配的错误，也就是说**ArrayList不是类型安全的**。既使我们保证在插入数据的时候都很小心，都有插入了同一类型的数据，但在使用的时候，我们也需要**将它们转化为对应的原类型来处理**。这就存在了装箱与拆箱的操作，会带来很大的性能损耗。

### List

List类是ArrayList类的泛型等效类。它的大部分用法都与ArrayList相似，因为List类也继承了IList接口。最关键的区别在于，在声明List集合时，我们同时需要为其声明List集合内数据的对象类型。 比如：

```cpp
List<int> list = new List<int>();   or   List<int> list = new ArrayList<>();
//新增数据
 list.Add(123);
//修改数据 
list[0] = 345;
//移除数据
list.RemoveAt(0);
```

如果我们往List集合中插入string字符"hello world"，IDE就会报错，且不能通过编译。这样就避免了前面讲的类型安全问题与装箱拆箱的性能问题了。**也就是如果使用List,那么集合内的数据类型有且只能是一种,不允许多种**

***



# Java两种数据类型

1.1 Java两种数据类型分类
（1）基本数据类型，分为boolean、byte、int、char、long、short、double、float；
（2）引用数据类型 ，分为数组、类、接口。

1.2 Java为每个基本数据类型提供了封装类
为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每 一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。

基本数据类型: boolean，char，byte，short，int，long，float，double
封装类类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double

2 int与Integer的基本使用对比
Integer是int的包装类；int是基本数据类型；
Integer变量必须实例化后才能使用；int变量不需要；
Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；
Integer的默认值是null；int的默认值是0。
3 int与Integer的深入对比
（1）由于Integer变量实际上是对一个Integer对象的引用，所以两个通过new生成的Integer变量永远是不相等的（因为new生成的是两个对象，其内存地址不同）。

```java
Integer i = new Integer(100);
Integer j = new Integer(100);
System.out.print(i == j); //false
```

（2）Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）

```java
Integer i = new Integer(100);
int j = 100；
System.out.print(i == j); //true
```

（3）非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。因为非new生成的Integer变量指向的是静态常量池中cache数组中存储的指向了堆中的Integer对象，而new Integer()生成的变量指向堆中新建的对象，两者在内存中的对象引用（地址）不同。

```java
Integer i = new Integer(100);
Integer j = 100;
System.out.print(i == j); //false
```

（4）对于两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，如果两个变量的值不在此区间，则比较结果为false

```java
Integer i = 100;
Integer j = 100;
System.out.print(i == j); //true

Integer i = 128;
Integer j = 128;
System.out.print(i == j); //false
```

对于第4条的原因： java在编译Integer i = 100 ;时，会翻译成为Integer i = Integer.valueOf(100)。而java API中对Integer类型的valueOf的定义如下，对于-128到127之间的数，会进行缓存，Integer i = 127时，会将127这个Integer对象进行缓存，下次再写Integer j = 127时，就会直接从缓存中取，就不会new了。

```java
public static Integer valueOf(int i){
    assert IntegerCache.high >= 127;
    if (i >= IntegerCache.low && i <= IntegerCache.high){
        return IntegerCache.cache[i + (-IntegerCache.low)];
    }
    return new Integer(i);
}
```



4 自动装箱和自动拆箱——解释2（2）

4.1 自动装箱：将基本数据类型重新转化为对象

```java
    public class Test {  
        public static void main(String[] args) {  
            // 声明一个Integer对象，用到了自动的装箱：解析为:Integer num = Integer.valueOf(9);
	        Integer num = 9;
        }  
    }  
```

9是属于基本数据类型的，原则上它是不能直接赋值给一个对象Integer的。但jdk1.5后你就可以进行这样的声明，自动将基本数据类型转化为对应的封装类型，成为一个对象以后就可以调用对象所声明的所有的方法。

4.2 自动拆箱：将对象重新转化为基本数据类型            

```java
        public class Test {  
        public static void main(String[] args) {  
            / /声明一个Integer对象
	        Integer num = 9;
       // 进行计算时隐含的有自动拆箱
	    System.out.print(num--);
    }  
}  
```

因为对象时不能直接进行运算的，而是要转化为基本数据类型后才能进行加减乘除。对比：

// 装箱
Integer num = 10;
// 拆箱
int num1 = num;

5 深入解析Integer——解释2（3/4）
5.1 问题描述                     

```java
           public class Test {  
        public static void main(String[] args) {  
	        // 在-128~127 之外的数
            Integer num1 = 128;   
            Integer num2 = 128;           
            System.out.println(num1==num2);   //false
        // 在-128~127 之内的数 
        Integer num3 = 9;   
        Integer num4 = 9;   
        System.out.println(num3==num4);   //true
    }  
}  
```

解析原因：归结于java对于Integer与int的自动装箱与拆箱的设计，是一种模式：叫享元模式（flyweight）。
（1）加大对简单数字的重利用，Java定义在自动装箱时对于在-128~127之内的数值，它们被装箱为Integer对象后，会存在内存中被重用，始终只存在一个对象。
（2）而如果在-128~127之外的数，被装箱后的Integer对象并不会被重用，即相当于每次装箱时都新建一个 Integer对象。

5.2 Integer源码解析
给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf，源码如下
